---
title: 前端通识
date: 2022-08-03 13:58:14
summary: 前端通用知识总结
tags:
- 面试
categories:
- [前端进阶]
---

### 3. 微前端
一种由独立交付的多个前端应用组成整体的架构风格。具体的，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品。  
将庞大的整体拆成可控的小块，并明确它们之间的依赖关系。关键优势在于：  
- 代码库更小，更内聚、可维护性更高
- 松耦合、自治的团队可扩展性更好
- 增量升级，独立部署，重写部分前端功能成为了可能

实现中的关键问题：  
- 多个 Bundle 如何集成？    
微前端架构中一般会有个容器应用（container application）将各子应用集成起来。集成方式分3类：  
  - 服务端集成：如 SSR 拼装模板
  - 构建时集成：如 Code Splitting
  - 运行时集成：如通过 iframe、JS、Web Components 等方式

- 子应用之间怎样隔离影响？
  - 样式隔离：开发规范（如BEM）、CSS 预处理（如SASS）、模块定义（如CSS Module）、用 JS 来写（CSS-in-JS）、以及shadow DOM特性
  - 作用域隔离：各种模块定义（如ES Module、AMD、Common Module、UMD）
- 公共资源如何复用？
  - 比较推荐的模式是开源软件的管理模式：所有人都能补充公共资源，但要有人（或一个团队）负责监管，以保证质量、一致性以及正确性
- 子应用间怎样通信？
  - 自定义事件
  - 路由
  - props传递数据等
- 如何测试？  
每个子应用都应该有自己的全套测试方案，特殊之处在于，除单元测试、功能测试外，还要有集成测试：
  - 集成测试：保证子应用间集成的正确性，比如跨子应用的交互操作
  - 功能测试：保证页面组装的正确性
  - 单元测试：保证底层业务逻辑和渲染逻辑的正确性

### 4. 服务端渲染
**客户端渲染（CSR）**：使用 JavaScript 框架进行页面渲染
**服务端渲染（SSR）**：服务端将HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。

**为什么使用服务端渲染?**
**优点：**
- 更快的首屏加载速度：因为浏览器不需要等待数据加载和渲染，因此可以提高用户的首屏体验。
- 更好的搜索引擎优化（SEO）：因为搜索引擎可以更容易地爬取完整的HTML内容，因此SSR可以更好地改善网站的SEO。
- 更好的用户体验：因为页面的内容在服务器端渲染，因此用户可以更快地看到完整的页面，从而提高用户的使用体验。

**缺点：**
- 增加服务器的负载：因为服务器需要执行渲染任务，因此可能会增加服务器的负载。
- 更复杂的环境技术：因为需要涉及到服务器端代码，因此需要更复杂的技术环境。
- 更高的开发复杂度：因为需要在服务器端和客户端同时开发，因此可能会更高的开发复杂度。

**服务端渲染框架**
- Vue项目：[Nuxt.js](https://www.nuxtjs.cn/guide/installation)、[Vue SSR指南](https://v2.ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr)
- React项目：[Next.js](https://www.nextjs.cn/)

### 5. Serverless架构
💡[Serverless（无服务）基础知识](https://juejin.cn/post/6844903904224903181)

### 6. 前端缓存
💡[前端缓存详解](https://www.jianshu.com/p/256d0873c398)

### 7. OAuth2.0
开放授权（OAuth）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。
- 思路  
OAuth在"客户端"与"服务提供商"之间，设置了一个授权层（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。  
"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。
- 运行流程  
  1. 用户打开客户端以后，客户端要求用户给予授权。
  2. 用户同意给予客户端授权。
  3. 客户端使用上一步获得的授权，向认证服务器申请令牌。
  4. 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。
  5. 客户端使用令牌，向资源服务器申请获取资源。
  6. 资源服务器确认令牌无误，同意向客户端开放资源。
- 授权模式
  - 授权码模式（authorization code）
  - 简化模式（implicit）
  - 密码模式（resource owner password credentials）
  - 客户端模式（client credentials）

### 8. Ajax、Axios和fetch的区别
- `Ajax`是指一种无需刷新页面即可向服务器请求数据的技术。核心是`XMLHttpRequest对象`（简称`XHR`）。  
- `Axios`是通过 `Promise` 实现 `XHR` 封装的 `JavaScript` 库，在浏览器和`Node.js`环境中都可以运行。  
- `fetch` 是 `JavaScript` 原生库，是`Ajax`的替代方案，没有使用XMLHttpRequest对象。只可以在浏览器上使用。

### 9. XSS攻击
💡[如何防止XSS攻击？](https://tech.meituan.com/2018/09/27/fe-security.html)

### 10. Babel原理

### 11. 基于session的认证流程
1. 用户使用用户名和密码登录；
2. 服务端认证通过后创建一条 session，并生成一个token与之关联，返回响应数据的同时将token保存至客户端 cookie 中；
3. 客户端再请求时，自动携带cookie中的 token；
4. 服务端解析 cookie 后根据 token 去查找对应的 session 信息，如果对应 session 存在且合法，则返回正确响应数据；
5. 服务端若未找到对应 session 信息，则返回错误提示；
6. 客户端获取错误提示后，指引用户重新登录。
### 12. JWT认证流程
1. 用户使用用户名和密码登录；
2. 服务端认证通过后，生成 token，返回客户端；
3. 客户端保存 token，并携带 token，请求服务端资源；
4. 服务端判断 token 是否过期，若没有过期，则解析 token 获取认证相关信息，认证通过后，将服务器资源返回给客户端；
5. 服务端若判断 token 已过期，返回 token 过期提示；
6. 客户端获取 token 过期提示后，指引用户重新登录。

### 13. axios拦截器原理


### 14. 长列表优化
- 时间分片（适用于简单dom）
  - 按照一定的时间间隔来分批渲染数据，避免数据同时一次性插入过多dom导致页面卡顿，常用的实现是通过`requestAnimationFrame`和`DocumentFragment`来间歇性的渲染dom
- 虚拟列表（适用于复杂dom）
  - 只对可见区域进行渲染，对非可见区域中的数据利用等高的占位元素来替代，从而减少页面中的DOM节点数量，以提升渲染速度


**参考文章**
[「前端进阶」高性能渲染十万条数据(虚拟列表)](https://juejin.cn/post/6844903982742110216)
[「前端进阶」高性能渲染十万条数据(时间分片)](https://juejin.cn/post/6844903938894872589)

### 15. 单点登录