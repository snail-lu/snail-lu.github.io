---
title: 前端通识
date: 2022-08-03 13:58:14
summary: 前端通用知识总结
tags:
- 面试
categories:
- [前端进阶]
---

### 1. 回流和重绘
#### 概念
- **回流(reflow)**：`Render Tree`中部分或全部元素的几何尺寸发生改变，浏览器重新计算元素的几何属性并调整布局的过程，也称**重排**。
- **重绘(repaint)**：`Render tree`中的一些元素只发生样式的改变并不影响它在文档流中的位置时，浏览器不需重新计算元素的几何属性、直接为元素绘制新的样式的过程。

#### 区别：
回流必将引起重绘，重绘不一定会引起回流。

#### 回流的触发场景
- 页面首次渲染
- 浏览器的窗口尺寸变化
- 元素的位置/尺寸/内容/字体大小发生变化
- 添加或删除可见的DOM元素
- 查询一些属性或方法
  - clientTop、clientLeft、clientWidth、clientHeight
  - offsetTop、offsetLeft、 offsetWidth、offsetHeight
  - scrollTop、scrollLeft、scrollWidth、scrollHeight
  - scrollIntoView()、scrollIntoViewIfNeeded()、getComputedStyle()、getBoundingClientRect()、scrollTo()

#### 重绘的触发场景
- 回流
- 一些CSS属性的改变
  - color、border-style、visibility、background、text-decoration、background-image、background-position、background-repeat、outline-color、outline、outline-style、border-radius、outline-width、box-shadow、background-size

### 2. BFC
#### 概念
**BFC(Block Formatting context)**：块级格式化上下文。具有 `BFC` 特性的元素可以看作是隔离了的独立容器，拥有不影响外界且不被外界所影响的布局规则。

#### 触发BFC
- 根元素（`html`）
- 浮动元素（`float` 值不为 `none`）
- 绝对定位元素（`position` 值为 `absolute` 或 `fixed`）
- 行内块元素（`display` 值为 `inline-block`）
- 表格单元格（`display` 值为 `table-cell`，HTML 表格单元格默认值）
- 表格标题（`display` 值为 `table-caption`，HTML 表格标题默认值）
- 匿名表格单元格元素（`display` 值为 `table`、`table-row`、 `table-row-group`、`table-header-group`、`table-footer-group`（分别是 HTML table、tr、tbody、thead、tfoot 的默认值）或 `inline-table`）
- `overflow` 值不为 `visible`、`clip` 的块元素
- `display` 值为 `flow-root` 的元素
- `contain` 值为 `layout`、`content` 或 `paint` 的元素
- 弹性元素（`display` 值为 `flex` 或 `inline-flex` 元素的直接子元素），如果它们本身既不是 `flex`、`grid` 也不是 `table` 容器
- 网格元素（`display` 值为 `grid` 或 `inline-grid` 元素的直接子元素），如果它们本身既不是 `flex`、`grid` 也不是 `table` 容器
- 多列容器（`column-count` 或 `column-width (en-US)` 值不为 `auto`，包括`column-count` 为 `1`）
- `column-span` 值为 `all` 的元素始终会创建一个新的 BFC，即使该元素没有包裹-在一个多列容器中 (规范变更, Chrome bug)
#### BFC布局规则
- **包含内部浮动**
    开启了BFC的元素在计算高度时，浮动的元素也包含在内，即父元素会被浮动的子元素撑开。
- **排除外部浮动**
    开启了BFC的元素会阻止自己的文字内容去环绕相邻的浮动元素
- **阻止外边距重叠**
    开启了BFC的元素会阻止自己与相邻元素的`margin-top`或`margin-bottom`发生重叠。
- **阻止外边距塌陷**
    开启了BFC的元素会阻止自己的`margin-top`产生伪作用于父元素的现象。

### 3. 微前端
一种由独立交付的多个前端应用组成整体的架构风格。具体的，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，而在用户看来仍然是内聚的单个产品。  
将庞大的整体拆成可控的小块，并明确它们之间的依赖关系。关键优势在于：  
- 代码库更小，更内聚、可维护性更高
- 松耦合、自治的团队可扩展性更好
- 增量升级，独立部署，重写部分前端功能成为了可能

实现中的关键问题：  
- 多个 Bundle 如何集成？    
微前端架构中一般会有个容器应用（container application）将各子应用集成起来。集成方式分3类：  
  - 服务端集成：如 SSR 拼装模板
  - 构建时集成：如 Code Splitting
  - 运行时集成：如通过 iframe、JS、Web Components 等方式

- 子应用之间怎样隔离影响？
  - 样式隔离：开发规范（如BEM）、CSS 预处理（如SASS）、模块定义（如CSS Module）、用 JS 来写（CSS-in-JS）、以及shadow DOM特性
  - 作用域隔离：各种模块定义（如ES Module、AMD、Common Module、UMD）
- 公共资源如何复用？
  - 比较推荐的模式是开源软件的管理模式：所有人都能补充公共资源，但要有人（或一个团队）负责监管，以保证质量、一致性以及正确性
- 子应用间怎样通信？
  - 自定义事件
  - 路由
  - props传递数据等
- 如何测试？  
每个子应用都应该有自己的全套测试方案，特殊之处在于，除单元测试、功能测试外，还要有集成测试：
  - 集成测试：保证子应用间集成的正确性，比如跨子应用的交互操作
  - 功能测试：保证页面组装的正确性
  - 单元测试：保证底层业务逻辑和渲染逻辑的正确性

### 4. 服务端渲染
**客户端渲染（CSR）**：使用 JavaScript 框架进行页面渲染
**服务端渲染（SSR）**：服务端将HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。

**为什么使用服务端渲染?**
**优点：**
- 更快的首屏加载速度：因为浏览器不需要等待数据加载和渲染，因此可以提高用户的首屏体验。
- 更好的搜索引擎优化（SEO）：因为搜索引擎可以更容易地爬取完整的HTML内容，因此SSR可以更好地改善网站的SEO。
- 更好的用户体验：因为页面的内容在服务器端渲染，因此用户可以更快地看到完整的页面，从而提高用户的使用体验。

**缺点：**
- 增加服务器的负载：因为服务器需要执行渲染任务，因此可能会增加服务器的负载。
- 更复杂的环境技术：因为需要涉及到服务器端代码，因此需要更复杂的技术环境。
- 更高的开发复杂度：因为需要在服务器端和客户端同时开发，因此可能会更高的开发复杂度。

**服务端渲染框架**
- Vue项目：[Nuxt.js](https://www.nuxtjs.cn/guide/installation)、[Vue SSR指南](https://v2.ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr)
- React项目：[Next.js](https://www.nextjs.cn/)

### 5. Serverless架构

### 6. 前端缓存
![](https://s1.ax1x.com/2022/09/18/xpjEQA.jpg)

### 7. OAuth2.0
开放授权（OAuth）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。
- 思路  
OAuth在"客户端"与"服务提供商"之间，设置了一个授权层（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。  
"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。
- 运行流程  
  1. 用户打开客户端以后，客户端要求用户给予授权。
  2. 用户同意给予客户端授权。
  3. 客户端使用上一步获得的授权，向认证服务器申请令牌。
  4. 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。
  5. 客户端使用令牌，向资源服务器申请获取资源。
  6. 资源服务器确认令牌无误，同意向客户端开放资源。
- 授权模式
  - 授权码模式（authorization code）
  - 简化模式（implicit）
  - 密码模式（resource owner password credentials）
  - 客户端模式（client credentials）

### 8. Ajax、Axios和fetch的区别。
- `Ajax`是指一种无需刷新页面即可向服务器请求数据的技术。核心是`XMLHttpRequest对象`（简称`XHR`）。  
- `Axios`是通过 `Promise` 实现 `XHR` 封装的 `JavaScript` 库，在浏览器和`Node.js`环境中都可以运行。  
- `fetch` 是 `JavaScript` 原生库，是`Ajax`的替代方案，没有使用XMLHttpRequest对象。只可以在浏览器上使用。

### 9. XSS攻击的特点及如何防范

### 10. Babel原理

### 11. 基于session的认证流程
1. 用户使用用户名和密码登录；
2. 服务端认证通过后创建一条 session，并生成一个token与之关联，返回响应数据的同时将token保存至客户端 cookie 中；
3. 客户端再请求时，自动携带cookie中的 token；
4. 服务端解析 cookie 后根据 token 去查找对应的 session 信息，如果对应 session 存在且合法，则返回正确响应数据；
5. 服务端若未找到对应 session 信息，则返回错误提示；
6. 客户端获取错误提示后，指引用户重新登录。
### 12. JWT认证流程
1. 用户使用用户名和密码登录；
2. 服务端认证通过后，生成 token，返回客户端；
3. 客户端保存 token，并携带 token，请求服务端资源；
4. 服务端判断 token 是否过期，若没有过期，则解析 token 获取认证相关信息，认证通过后，将服务器资源返回给客户端；
5. 服务端若判断 token 已过期，返回 token 过期提示；
6. 客户端获取 token 过期提示后，指引用户重新登录。

### 13. axios拦截器原理


### 14. 长列表优化
- 时间分片（适用于简单dom）
  - 按照一定的时间间隔来分批渲染数据，避免数据同时一次性插入过多dom导致页面卡顿，常用的实现是通过`requestAnimationFrame`和`DocumentFragment`来间歇性的渲染dom
- 虚拟列表（适用于复杂dom）
  - 只对可见区域进行渲染，对非可见区域中的数据利用等高的占位元素来替代，从而减少页面中的DOM节点数量，以提升渲染速度


**参考文章**
[「前端进阶」高性能渲染十万条数据(虚拟列表)](https://juejin.cn/post/6844903982742110216)
[「前端进阶」高性能渲染十万条数据(时间分片)](https://juejin.cn/post/6844903938894872589)

### 15. 单点登录